<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        
        <!-- A-Frame -->
        <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>

        <!-- Supprimer grabbable natif (éviter conflit avec super-hands) -->
        <script>
        if (AFRAME.components && AFRAME.components['grabbable']) {
            delete AFRAME.components['grabbable'];
        }
        </script>

        <!-- extras & physics & super-hands -->
        <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.2/dist/aframe-extras.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@c-frame/aframe-physics-system@4.2.3/dist/aframe-physics-system.min.js"></script>
        <script src="https://unpkg.com/super-hands@3.0.5/dist/super-hands.min.js"></script>

        <style>body { margin: 0; }</style>
    </head>

    <body>
        <!-- Scene: augmenter précision des collisions via iterations -->
        <a-scene
        physics="gravity: -9.81; driver: cannon; iterations: 20"
        shadow="type: pcfsoft"
        renderer="antialias: true"
        vr-mode-ui="enabled: true"
        device-orientation-permission-ui="enabled: true"
        >
        <a-assets>
            <img id="sky" src="sky1.png">
            <a-asset-item id="gunModel" src="assets/scene.gltf"></a-asset-item>
            <!-- Sons -->
            <audio id="shootSound" src="assets/shot.mp3" preload="auto"></audio>
            <audio id="hitSound" src="assets/hit.mp3" preload="auto"></audio>
        </a-assets>

        <!-- Lights -->
        <a-entity light="type: ambient; color: #ffffff; intensity: 0.5"></a-entity>
        <a-entity light="type: directional; intensity: 0.8; castShadow: true" position="-2 4 -3"></a-entity>

        <!-- RIG + camera + mains -->
        <a-entity id="rig" position="0 0.35 0" joystick-movement="speed: 2" snap-turn="angle: 30; cooldown: 300">
            <a-entity id="head" camera look-controls wasd-controls="enabled: false"></a-entity>

            <a-entity id="leftHand"
                    oculus-touch-controls="hand: left"
                    super-hands="grabStartButtons: gripdown, squeezestart; grabEndButtons: gripup, squeezeend"
                    sphere-collider="objects: .grabbable"
                    static-body="shape: sphere; sphereRadius: 0.03"></a-entity>

            <a-entity id="rightHand"
                    oculus-touch-controls="hand: right"
                    super-hands="grabStartButtons: gripdown, squeezestart; grabEndButtons: gripup, squeezeend"
                    sphere-collider="objects: .grabbable"
                    static-body="shape: sphere; sphereRadius: 0.03"></a-entity>
        </a-entity>

        <!-- Ground (agrandi) -->
        <a-plane position="0 0 0" rotation="-90 0 0" width="75" height="75"
                color="#7BC8A4" static-body shadow="receive: true"></a-plane>

        <!-- Table -->
        <a-box id="table"
                position="0 0.5 -3"
                scale="2 0.7 2"
                color="#4CC3D9"
                shadow
                static-body="collisionFilterGroup:2; collisionFilterMask:1">
        </a-box>

        <!-- Gun -->
        <a-entity id="gun" rotation="0 0 0"
                    class="grabbable"
                    gltf-model="#gunModel"
                    position="0.10047 1.17377 -3.01759"
                    scale="1.4 1.4 1.4"
                    shadow
                    dynamic-body="mass: 1; shape: box"
                    toggle-hold="position: 0 -0.02 -0.04; rotation: 70 180 0"
                    gun-shoot="speed: 50">
            <!-- Tracker (muzzle) -->
            <a-entity id="tracker" position="-0.00293 0.0198 0.28446"></a-entity>
            <!-- Sound entity (gun shot) -->
            <a-entity id="gunSound" sound="src: #shootSound; autoplay: false; positional: true; loop: false"></a-entity>
        </a-entity>

        <a-sky src="#sky"></a-sky>
        </a-scene>

        <script>
        // ------------------------
        // Movement & snap-turn (inchangés)
        // ------------------------
        AFRAME.registerComponent('joystick-movement', {
        schema: { speed: { type: 'number', default: 2 } },
        init: function () {
            const rig = document.querySelector('#rig');
            const head = document.querySelector('#head');
            const leftHand = document.querySelector('#leftHand');
            const speed = this.data.speed;
            const DEADZONE = 0.1;
            if (!leftHand) return;

            leftHand.addEventListener('thumbstickmoved', function (evt) {
            const dx = evt.detail.x, dy = evt.detail.y;
            if (Math.abs(dx) < DEADZONE && Math.abs(dy) < DEADZONE) return;

            const forward = new THREE.Vector3();
            head.object3D.getWorldDirection(forward);
            forward.y = 0; forward.normalize();

            const right = new THREE.Vector3();
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).negate();

            const step = 0.05 * speed;
            const rigPos = rig.object3D.position;
            rigPos.addScaledVector(forward, dy * step);
            rigPos.addScaledVector(right, dx * step);
            });
        }
        });

        AFRAME.registerComponent('snap-turn', {
        schema: { angle: { type: 'number', default: 30 }, cooldown: { type: 'number', default: 300 } },
        init: function () {
            const rig = document.querySelector('#rig');
            const rightHand = document.querySelector('#rightHand');
            const angle = this.data.angle;
            const cooldown = this.data.cooldown;
            let lastTurn = 0;
            if (!rightHand) return;

            rightHand.addEventListener('thumbstickmoved', function (evt) {
            const now = Date.now(), x = evt.detail.x;
            if (Math.abs(x) < 0.8 || now - lastTurn < cooldown) return;
            const rad = THREE.MathUtils.degToRad(angle);
            if (x > 0.8) rig.object3D.rotation.y -= rad;
            else rig.object3D.rotation.y += rad;
            lastTurn = now;
            });
        }
        });

        // ------------------------
        // toggle-hold (comme tu avais)
        // ------------------------
        AFRAME.registerComponent('toggle-hold', {
        schema: {
            position: { type: 'vec3', default: { x: 0, y: 0, z: 0 } },
            rotation: { type: 'vec3', default: { x: 0, y: 0, z: 0 } }
        },
        init: function () {
            this._held = false;
            this._handEl = null;
            this._savedDynamic = null;

            this._onGrabStart = this._onGrabStart.bind(this);
            this._onGripDown = this._onGripDown.bind(this);

            this.el.addEventListener('grab-start', this._onGrabStart);
        },
        _onGrabStart: function (evt) {
            if (this._held) return;
            const hand = evt.detail?.hand;
            if (!hand) return;

            if (this.el.hasAttribute('dynamic-body')) {
            this._savedDynamic = this.el.getAttribute('dynamic-body');
            this.el.removeAttribute('dynamic-body');
            }

            hand.object3D.attach(this.el.object3D);

            const pos = this.data.position;
            this.el.object3D.position.set(pos.x, pos.y, pos.z);
            const rot = this.data.rotation;
            this.el.object3D.rotation.set(
            THREE.MathUtils.degToRad(rot.x),
            THREE.MathUtils.degToRad(rot.y),
            THREE.MathUtils.degToRad(rot.z)
            );

            this._held = true;
            this._handEl = hand;
            hand.addEventListener('gripdown', this._onGripDown);
        },
        _onGripDown: function () {
            if (!this._held || !this._handEl) return;

            this._handEl.sceneEl.object3D.attach(this.el.object3D);

            if (this._savedDynamic) {
            this.el.setAttribute('dynamic-body', this._savedDynamic);
            this._savedDynamic = null;
            }

            this._handEl.removeEventListener('gripdown', this._onGripDown);
            this._held = false;
            this._handEl = null;
        }
        });

        // ------------------------
        // projectile component: handles physics + manual proximity checking
        // ------------------------
        AFRAME.registerComponent('projectile', {
        schema: {
            speed: { type: 'number', default: 50 },
            lifetime: { type: 'number', default: 3000 },
            radius: { type: 'number', default: 0.03 }, // used for proximity test
            checkInterval: { type: 'number', default: 16 } // ms between proximity checks
        },
        init: function () {
            this._tickAccumulator = 0;
            this._lastCheck = performance.now();
            this.targetSelector = '.target';
            this._onBodyLoaded = this._onBodyLoaded.bind(this);
            this._onCollide = this._onCollide.bind(this);

            this.el.addEventListener('body-loaded', this._onBodyLoaded);
            this.el.addEventListener('collide', this._onCollide);

            // auto-remove after lifetime
            setTimeout(() => {
            if (this.el.parentNode) this.el.parentNode.removeChild(this.el);
            }, this.data.lifetime);
        },
        _onBodyLoaded: function () {
            // nothing here because velocity is set from gun-shoot when created
        },
        _onCollide: function (evt) {
            // safe handling: only remove target (not the bullet) and respawn
            const otherEl = evt.detail?.body?.el;
            if (!otherEl) return;
            if (otherEl.classList && otherEl.classList.contains('target')) {
            // play hit sound if present
            const hitSound = otherEl.querySelector('.hitSound');
            if (hitSound?.components?.sound) {
                try { hitSound.components.sound.stopSound(); } catch (e) {}
                try { hitSound.components.sound.playSound(); } catch (e) { console.warn('hit play error', e); }
            }
            // remove target in next tick for safety and respawn
            setTimeout(() => {
                if (otherEl.parentNode) otherEl.parentNode.removeChild(otherEl);
                spawnTarget();
            }, 0);
            }
        },
        tick: function (t, dt) {
            // do a cheap proximity check to avoid tunneling (check every checkInterval ms)
            this._tickAccumulator += dt;
            if (this._tickAccumulator < this.data.checkInterval) return;
            this._tickAccumulator = 0;

            const scene = this.el.sceneEl;
            if (!scene) return;
            const targets = scene.querySelectorAll(this.targetSelector);
            if (!targets || targets.length === 0) return;

            // get bullet world pos
            const bPos = new THREE.Vector3();
            if (!this.el.object3D) return;
            this.el.object3D.getWorldPosition(bPos);

            for (let i = 0; i < targets.length; i++) {
            const target = targets[i];
            // target world pos
            const tPos = new THREE.Vector3();
            if (!target.object3D) continue;
            target.object3D.getWorldPosition(tPos);

            const dist = bPos.distanceTo(tPos);
            // threshold: sum of radii + small margin
            const threshold = (this.data.radius) + 0.25; // target half-size ~0.15, margin to be safe
            if (dist <= threshold) {
                // Hit detected by proximity fallback
                const hitSound = target.querySelector('.hitSound');
                if (hitSound?.components?.sound) {
                try { hitSound.components.sound.stopSound(); } catch (e) {}
                try { hitSound.components.sound.playSound(); } catch (e) { console.warn('hit play error', e); }
                }
                // remove target and respawn, remove bullet
                if (target.parentNode) target.parentNode.removeChild(target);
                spawnTarget();
                if (this.el.parentNode) this.el.parentNode.removeChild(this.el);
                return; // bullet removed — stop processing
            }
            }
        }
        });

        // ------------------------
        // gun-shoot component (creates projectile and sets velocity)
        // ------------------------
        AFRAME.registerComponent('gun-shoot', {
        schema: {
            speed: { type: 'number', default: 20 },
            lifetime: { type: 'number', default: 3000 }
        },
        init: function () {
            this._onTriggerDown = this._onTriggerDown.bind(this);
            this.tracker = this.el.querySelector('#tracker');
            this.soundEntity = this.el.querySelector('#gunSound');

            this.el.addEventListener('grab-start', evt => {
            const hand = evt.detail?.hand;
            if (hand) hand.addEventListener('triggerdown', this._onTriggerDown);
            });
            this.el.addEventListener('grab-end', evt => {
            const hand = evt.detail?.hand;
            if (hand) hand.removeEventListener('triggerdown', this._onTriggerDown);
            });
        },
        _onTriggerDown: function () {
            const th = this.el.components['toggle-hold'];
            if (!th || !th._held) return;
            if (!this.tracker) return;

            // play gun sound
            if (this.soundEntity?.components?.sound) {
            try { this.soundEntity.components.sound.stopSound(); } catch (e) {}
            try { this.soundEntity.components.sound.playSound(); } catch (e) { console.warn('playSound error', e); }
            }

            // create bullet
            const bullet = document.createElement('a-sphere');
            const radius = 0.04; // slightly larger to reduce tunneling
            bullet.setAttribute('radius', radius);
            bullet.setAttribute('color', 'yellow');
            bullet.setAttribute('shadow', 'cast: true');
            bullet.setAttribute('dynamic-body', `mass:0.02; shape:sphere; sphereRadius:${radius}`);
            bullet.classList.add('projectile');

            // position at tracker muzzle
            const worldPos = new THREE.Vector3();
            this.tracker.object3D.getWorldPosition(worldPos);
            bullet.setAttribute('position', `${worldPos.x} ${worldPos.y} ${worldPos.z}`);

            // compute direction by tracker's world direction
            const direction = new THREE.Vector3(0, 0, -1);
            this.tracker.object3D.getWorldDirection(direction);
            direction.normalize();

            // append to scene (so physics body created)
            this.el.sceneEl.appendChild(bullet);

            const speed = this.data.speed;
            // when physics body is ready, set velocity attribute (aframe-physics-system)
            bullet.addEventListener('body-loaded', () => {
            bullet.setAttribute('velocity', `${direction.x * speed} ${direction.y * speed} ${direction.z * speed}`);
            });

            // add projectile behavior (handles proximity checks & collision removal)
            bullet.setAttribute('projectile', `speed: ${speed}; lifetime: ${this.data.lifetime}; radius: ${radius}`);

            // don't remove on collide here: projectile component handles collisions
        }
        });

        // ------------------------
        // Target spawning (single target at a time) + respawn logic
        // ------------------------
        function spawnTarget() {
        const scene = document.querySelector('a-scene');
        if (!scene) return;

        // Remove any existing target
        const existing = scene.querySelectorAll('.target');
        existing.forEach(e => e.remove());

        const target = document.createElement('a-box');
        target.setAttribute('class', 'target');
        target.setAttribute('color', 'red');
        target.setAttribute('depth', '0.3');
        target.setAttribute('height', '0.3');
        target.setAttribute('width', '0.3');
        target.setAttribute('shadow', 'cast: true; receive: true');
        // static-body is fine, but use dynamic-body with mass 0 to ensure body exists reliably:
        target.setAttribute('dynamic-body', 'mass:0; shape:box');

        // attach hit sound entity (positional)
        const sound = document.createElement('a-entity');
        sound.setAttribute('class', 'hitSound');
        sound.setAttribute('sound', 'src: #hitSound; autoplay: false; positional: true; loop: false');
        target.appendChild(sound);

        // random position in front of player
        const x = (Math.random() - 0.5) * 8;     // -4 .. 4
        const y = 1 + Math.random() * 1.5;       // 1 .. 2.5
        const z = -3 - Math.random() * 6;        // -3 .. -9
        target.setAttribute('position', `${x} ${y} ${z}`);

        scene.appendChild(target);

        // small timeout to ensure physics body is created before interaction
        setTimeout(() => {
            // nothing else needed — projectile's body-loaded / tick will detect
        }, 50);
        }

        // spawn initial target once DOM ready
        document.addEventListener('DOMContentLoaded', () => {
        // small delay to ensure scene and physics initialized
        setTimeout(spawnTarget, 200);
        });
        </script>
    </body>
</html>
